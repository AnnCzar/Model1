/* __V3D_TEMPLATE__ - template-based file; delete this line to prevent this file from being updated */

'use strict';

window.addEventListener('load', e => {
    const params = v3d.AppUtils.getPageParams();
    createApp({
        containerId: 'v3d-container',
        fsButtonId: 'fullscreen-button',
        sceneURL: params.load || 'Model1.gltf',
        logicURL: params.logic || 'visual_logic.js',
    });
    createCameraSwitchButton();
});

async function createApp({containerId, fsButtonId = null, sceneURL, logicURL = ''}) {
    if (!sceneURL) {
        console.log('No scene URL specified');
        return;
    }

    // some puzzles can benefit from cache
    v3d.Cache.enabled = true;

    let PL = null, PE = null;
    if (v3d.AppUtils.isXML(logicURL)) {
        const PUZZLES_DIR = '/puzzles/';
        const logicURLJS = logicURL.match(/(.*)\.xml$/)[1] + '.js';
        PL = await new v3d.PuzzlesLoader().loadEditorWithLogic(PUZZLES_DIR, logicURLJS);
        PE = v3d.PE;
    } else if (v3d.AppUtils.isJS(logicURL)) {
        PL = await new v3d.PuzzlesLoader().loadLogic(logicURL);
    }

    let initOptions = { useFullscreen: true };
    if (PL) {
        initOptions = PL.execInitPuzzles({ container: containerId }).initOptions;
    }
    sceneURL = initOptions.useCompAssets ? `${sceneURL}.xz` : sceneURL;

    const disposeFullscreen = prepareFullscreen(containerId, fsButtonId,
            initOptions.useFullscreen);
    const preloader = createPreloader(containerId, initOptions, PE);

    const app = createAppInstance(containerId, initOptions, preloader, PE);
    app.addEventListener('dispose', () => disposeFullscreen && disposeFullscreen());

    if (initOptions.preloaderStartCb) initOptions.preloaderStartCb();
    app.loadScene(sceneURL, () => {
        app.enableControls();
        app.run();

        if (PE) PE.updateAppInstance(app);
        if (PL) PL.init(app, initOptions);

        runCode(app, PL);
    }, null, () => {
        console.log(`Can't load the scene ${sceneURL}`);
    });

    return { app, PL };
}


function createPreloader(containerId, initOptions, PE) {
    const preloader = initOptions.useCustomPreloader
            ? createCustomPreloader(initOptions.preloaderProgressCb,
            initOptions.preloaderEndCb)
            : new v3d.SimplePreloader({ container: containerId });

    if (PE) puzzlesEditorPreparePreloader(preloader, PE);

    return preloader;
}

function createCustomPreloader(updateCb, finishCb) {
    class CustomPreloader extends v3d.Preloader {
        constructor() {
            super();
        }

        onUpdate(percentage) {
            super.onUpdate(percentage);
            if (updateCb) updateCb(percentage);
        }

        onFinish() {
            super.onFinish();
            if (finishCb) finishCb();
        }
    }

    return new CustomPreloader();
}

/**
 * Modify the app's preloader to track the loading process in the Puzzles Editor.
 */
function puzzlesEditorPreparePreloader(preloader, PE) {
    const _onUpdate = preloader.onUpdate.bind(preloader);
    preloader.onUpdate = function(percentage) {
        _onUpdate(percentage);
        PE.loadingUpdateCb(percentage);
    }

    const _onFinish = preloader.onFinish.bind(preloader);
    preloader.onFinish = function() {
        _onFinish();
        PE.loadingFinishCb();
    }
}


function createAppInstance(containerId, initOptions, preloader, PE) {
    const ctxSettings = {};
    if (initOptions.useBkgTransp) ctxSettings.alpha = true;
    if (initOptions.preserveDrawBuf) ctxSettings.preserveDrawingBuffer = true;

    const app = new v3d.App(containerId, ctxSettings, preloader);
    if (initOptions.useBkgTransp) {
        app.clearBkgOnLoad = true;
        if (app.renderer) {
            app.renderer.setClearColor(0x000000, 0);
        }
    }

    // namespace for communicating with code generated by Puzzles
    app.ExternalInterface = {};
    prepareExternalInterface(app);
    if (PE) PE.viewportUseAppInstance(app);

    return app;
}


function prepareFullscreen(containerId, fsButtonId, useFullscreen) {
    const container = document.getElementById(containerId);
    const fsButton = document.getElementById(fsButtonId);

    if (!fsButton) {
        return null;
    }
    if (!useFullscreen) {
        if (fsButton) fsButton.style.display = 'none';
        return null;
    }

    const fsEnabled = () => document.fullscreenEnabled
            || document.webkitFullscreenEnabled
            || document.mozFullScreenEnabled
            || document.msFullscreenEnabled;
    const fsElement = () => document.fullscreenElement
            || document.webkitFullscreenElement
            || document.mozFullScreenElement
            || document.msFullscreenElement;
    const requestFs = elem => (elem.requestFullscreen
            || elem.mozRequestFullScreen
            || elem.webkitRequestFullscreen
            || elem.msRequestFullscreen).call(elem);
    const exitFs = () => (document.exitFullscreen
            || document.mozCancelFullScreen
            || document.webkitExitFullscreen
            || document.msExitFullscreen).call(document);
    const changeFs = () => {
        const elem = fsElement();
        fsButton.classList.add(elem ? 'fullscreen-close' : 'fullscreen-open');
        fsButton.classList.remove(elem ? 'fullscreen-open' : 'fullscreen-close');
    };

    function fsButtonClick(event) {
        event.stopPropagation();
        if (fsElement()) {
            exitFs();
        } else {
            requestFs(container);
        }
    }

    if (fsEnabled()) fsButton.style.display = 'inline';

    fsButton.addEventListener('click', fsButtonClick);
    document.addEventListener('webkitfullscreenchange', changeFs);
    document.addEventListener('mozfullscreenchange', changeFs);
    document.addEventListener('msfullscreenchange', changeFs);
    document.addEventListener('fullscreenchange', changeFs);

    const disposeFullscreen = () => {
        fsButton.removeEventListener('click', fsButtonClick);
        document.removeEventListener('webkitfullscreenchange', changeFs);
        document.removeEventListener('mozfullscreenchange', changeFs);
        document.removeEventListener('msfullscreenchange', changeFs);
        document.removeEventListener('fullscreenchange', changeFs);
    }

    return disposeFullscreen;
}


function prepareExternalInterface(app) {

}
// dziala bez resetu pozycji kamer


// function createCameraSwitchButton() {
//     // Create the button element
//     const switchButton = document.createElement('button');
//     switchButton.id = 'camera-switch-button';
//     switchButton.innerHTML = 'Switch Camera';
    
//     // Style the button to position it in the bottom right corner
//     switchButton.style.position = 'absolute';
//     switchButton.style.bottom = '20px';
//     switchButton.style.right = '20px';
//     switchButton.style.zIndex = '100';
//     switchButton.style.padding = '10px 15px';
//     switchButton.style.backgroundColor = '#333';
//     switchButton.style.color = 'white';
//     switchButton.style.border = 'none';
//     switchButton.style.borderRadius = '5px';
//     switchButton.style.cursor = 'pointer';
    
//     // Add hover effect
//     switchButton.style.transition = 'background-color 0.3s';
//     switchButton.addEventListener('mouseover', () => {
//         switchButton.style.backgroundColor = '#555';
//     });
//     switchButton.addEventListener('mouseout', () => {
//         switchButton.style.backgroundColor = '#333';
//     });
    
//     // Current camera index
//     let currentCameraIndex = 0;
//     const cameraNames = ['Camera(FPS)', 'Camera(orbit)'];
    
//     // Add click event to switch between cameras
//     switchButton.addEventListener('click', () => {
//         // Get the app instance
//         const app = v3d.apps[Object.keys(v3d.apps)[0]];
//         if (!app) return;
        
//         // Toggle camera index
//         currentCameraIndex = (currentCameraIndex + 1) % cameraNames.length;
//         const nextCamera = cameraNames[currentCameraIndex];
        
//         // Find the camera in the scene
//         const camera = app.scene.getObjectByName(nextCamera);
//         if (camera && camera.isCamera) {
//             // Set the new active camera
//             app.setCamera(camera);
//             console.log(`Switched to ${nextCamera}`);
//         } else {
//             console.warn(`Camera ${nextCamera} not found in the scene`);
//         }
//     });
    
//     // Add the button to the document body
//     document.body.appendChild(switchButton);
// }


function createCameraSwitchButton() {
    // Create the button element
    const switchButton = document.createElement('button');
    switchButton.id = 'camera-switch-button';
    switchButton.innerHTML = 'Switch Camera';
    
    // Style the button to position it in the bottom right corner
    switchButton.style.position = 'absolute';
    switchButton.style.bottom = '20px';
    switchButton.style.right = '20px';
    switchButton.style.zIndex = '100';
    switchButton.style.padding = '10px 15px';
    switchButton.style.backgroundColor = '#333';
    switchButton.style.color = 'white';
    switchButton.style.border = 'none';
    switchButton.style.borderRadius = '5px';
    switchButton.style.cursor = 'pointer';
    
    // Add hover effect
    switchButton.style.transition = 'background-color 0.3s';
    switchButton.addEventListener('mouseover', () => {
        switchButton.style.backgroundColor = '#555';
    });
    switchButton.addEventListener('mouseout', () => {
        switchButton.style.backgroundColor = '#333';
    });
    
    // Current camera index
    let currentCameraIndex = 0;
    const cameraNames = ['Camera(FPS)', 'Camera(orbit)'];
    
    // Store default camera positions and rotations
    const defaultCameraSettings = {};
    
    // Add click event to switch between cameras
    switchButton.addEventListener('click', () => {
        // Get the app instance
        const app = v3d.apps[Object.keys(v3d.apps)[0]];
        if (!app) return;
        
        // Toggle camera index
        currentCameraIndex = (currentCameraIndex + 1) % cameraNames.length;
        const nextCamera = cameraNames[currentCameraIndex];
        
        // Find the camera in the scene
        const camera = app.scene.getObjectByName(nextCamera);
        if (camera && camera.isCamera) {
            // Store default settings for the camera if not already stored
            if (!defaultCameraSettings[nextCamera]) {
                defaultCameraSettings[nextCamera] = {
                    position: {
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z
                    },
                    rotation: {
                        x: camera.rotation.x,
                        y: camera.rotation.y,
                        z: camera.rotation.z
                    },
                    quaternion: {
                        x: camera.quaternion.x,
                        y: camera.quaternion.y,
                        z: camera.quaternion.z,
                        w: camera.quaternion.w
                    },
                    target: app.controls && app.controls.target ? {
                        x: app.controls.target.x,
                        y: app.controls.target.y,
                        z: app.controls.target.z
                    } : null
                };
            }
            
            // Reset camera to default position and rotation
            const defaults = defaultCameraSettings[nextCamera];
            camera.position.set(defaults.position.x, defaults.position.y, defaults.position.z);
            
            // Reset rotation (using quaternion is more reliable for cameras)
            camera.quaternion.set(defaults.quaternion.x, defaults.quaternion.y, defaults.quaternion.z, defaults.quaternion.w);
            
            // Set the new active camera
            app.setCamera(camera);
            
            // Reset orbit controls target if applicable
            if (app.controls && app.controls.target && defaults.target) {
                app.controls.target.set(defaults.target.x, defaults.target.y, defaults.target.z);
                app.controls.update();
            }
            
            console.log(`Switched to ${nextCamera} and reset to default position/rotation`);
        } else {
            console.warn(`Camera ${nextCamera} not found in the scene`);
        }
    });
    
    // Add the button to the document body
    document.body.appendChild(switchButton);
    
    // Initialize default settings for cameras after scene is loaded
    const initDefaultCameraSettings = () => {
        const app = v3d.apps[Object.keys(v3d.apps)[0]];
        if (!app || !app.scene) return;
        
        cameraNames.forEach(cameraName => {
            const camera = app.scene.getObjectByName(cameraName);
            if (camera && camera.isCamera) {
                defaultCameraSettings[cameraName] = {
                    position: {
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z
                    },
                    rotation: {
                        x: camera.rotation.x,
                        y: camera.rotation.y,
                        z: camera.rotation.z
                    },
                    quaternion: {
                        x: camera.quaternion.x,
                        y: camera.quaternion.y,
                        z: camera.quaternion.z,
                        w: camera.quaternion.w
                    },
                    target: app.controls && app.controls.target ? {
                        x: app.controls.target.x,
                        y: app.controls.target.y,
                        z: app.controls.target.z
                    } : null
                };
            }
        });
    };
    
    // Try to initialize after a short delay to ensure scene is loaded
    setTimeout(initDefaultCameraSettings, 1000);
}

function runCode(app, puzzles) {
    createCameraSwitchButton();
}

